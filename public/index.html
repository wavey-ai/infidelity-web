<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Infidelity</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* Prevent scrollbars */
      background-color: black; /* Dark background */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<script>
  const canvas = document.getElementById('bgCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  resizeCanvas();

  window.addEventListener('resize', resizeCanvas);

  const totalImages = 28;
  const images = [];
  let imagesLoaded = 0;

  // Preload images
  for (let i = 1; i <= totalImages; i++) {
    const img = new Image();
    img.src = `/img/infidelity${i}.avif`;
    img.onload = () => {
      imagesLoaded++;
      if (imagesLoaded === totalImages) {
        startAnimation();
        setInterval(changeImage, 20000);
      }
    };
    images.push(img);
  }

  let currentImageIndex = Math.floor(Math.random() * totalImages);
  let nextImageIndex = (currentImageIndex + 1) % totalImages;
  let transitionProgress = 0;
  let transitioning = false;

  const staticCanvas = document.createElement('canvas');
  const staticCtx = staticCanvas.getContext('2d');
  let imageData, buffer32;

  function createStaticOverlay() {
    staticCanvas.width = canvas.width * 2;
    staticCanvas.height = canvas.height * 2;

    imageData = staticCtx.createImageData(staticCanvas.width, staticCanvas.height);
    buffer32 = new Uint32Array(imageData.data.buffer);

    const baseRed = 255;
    const baseGreen = 105;
    const baseBlue = 180;
    const baseColor = (255 << 24) | (baseBlue << 16) | (baseGreen << 8) | baseRed;

    buffer32.fill(baseColor);

    staticCtx.putImageData(imageData, 0, 0);
  }

  function updateStaticOverlay() {
    const totalPixels = buffer32.length;
    const pixelsToUpdate = Math.floor(totalPixels * 0.2); // 20% of total pixels

    for (let i = 0; i < pixelsToUpdate; i++) {
      const index = Math.floor(Math.random() * totalPixels);

      const baseRed = 255;
      const baseGreen = 105;
      const baseBlue = 180;

      // Add more noticeable random variations to each color channel
      const variationRange = 100; // Increased variation for more obvious sparkle
      const red = Math.min(255, Math.max(0, baseRed + (Math.random() - 0.5) * variationRange));
      const green = Math.min(255, Math.max(0, baseGreen + (Math.random() - 0.5) * variationRange));
      const blue = Math.min(255, Math.max(0, baseBlue + (Math.random() - 0.5) * variationRange));

      // Combine into a single uint32 value
      buffer32[index] = (255 << 24) | (blue << 16) | (green << 8) | red;
    }

    staticCtx.putImageData(imageData, 0, 0);
  }

  function drawScene() {
    const imgHeight = canvas.height;
    const currentImage = images[currentImageIndex];
    const nextImage = images[nextImageIndex];
    const imgWidthCurrent = currentImage.width * (imgHeight / currentImage.height);
    const imgWidthNext = nextImage.width * (imgHeight / nextImage.height);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (transitioning) {
      // Draw current image fading out
      ctx.globalAlpha = 1 - transitionProgress;
      ctx.drawImage(
        currentImage,
        0,
        0,
        currentImage.width,
        currentImage.height,
        (canvas.width - imgWidthCurrent) / 2,
        0,
        imgWidthCurrent,
        imgHeight
      );

      // Draw next image fading in
      ctx.globalAlpha = transitionProgress;
      ctx.drawImage(
        nextImage,
        0,
        0,
        nextImage.width,
        nextImage.height,
        (canvas.width - imgWidthNext) / 2,
        0,
        imgWidthNext,
        imgHeight
      );

      ctx.globalAlpha = 1; // Reset alpha

      // Apply static overlay with decreasing opacity using color burn blending mode
      const staticOpacity = 1 - transitionProgress; // Goes from 1 to 0
      ctx.globalAlpha = staticOpacity;

      // Save the current composite operation
      const prevCompositeOperation = ctx.globalCompositeOperation;

      // Set the composite operation to 'color-burn'
      ctx.globalCompositeOperation = 'color-burn';

      // Update the static overlay to make it sparkle
      updateStaticOverlay();

      ctx.drawImage(
        staticCanvas,
        0,
        0,
        staticCanvas.width,
        staticCanvas.height,
        0,
        0,
        canvas.width,
        canvas.height
      );

      // Restore the previous composite operation
      ctx.globalCompositeOperation = prevCompositeOperation;
      ctx.globalAlpha = 1; // Reset alpha

    } else {
      // Draw the current image at full opacity
      ctx.globalAlpha = 1;
      ctx.drawImage(
        currentImage,
        0,
        0,
        currentImage.width,
        currentImage.height,
        (canvas.width - imgWidthCurrent) / 2,
        0,
        imgWidthCurrent,
        imgHeight
      );
    }
  }

  function animate() {
    if (transitioning) {
      transitionProgress += 0.01;

      if (transitionProgress >= 1) {
        transitionProgress = 1; // Ensure it doesn't exceed 1
        transitioning = false;
        currentImageIndex = nextImageIndex; // Update currentImageIndex after transition
      }
    }

    drawScene();
    requestAnimationFrame(animate);
  }

  function changeImage() {
    if (!transitioning) { // Prevent starting a new transition if one is already in progress
      transitioning = true;
      transitionProgress = 0; // Reset transition progress

      nextImageIndex = (currentImageIndex + 1) % totalImages;

      createStaticOverlay(); // Prepare the static overlay
    }
  }

  function startAnimation() {
    animate();
    // Change image every 5 seconds
    setInterval(changeImage, 20000);
  }
</script>

</body>
</html>

