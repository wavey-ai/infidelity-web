<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Infidelity</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* Prevent scrollbars */
      background-color: black; /* Dark background */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<script>
  const canvas = document.getElementById('bgCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  resizeCanvas();

  window.addEventListener('resize', resizeCanvas);

  const totalImages = 32;
  const imagePaths = [];
  for (let i = 1; i <= totalImages; i++) {
    imagePaths.push(`/img/infidelity${i}.avif`);
  }

  // Fisher-Yates Shuffle Algorithm to randomize the images array
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  shuffleArray(imagePaths); // Shuffle the image paths array

  let currentImageIndex = 0;
  let nextImageIndex = (currentImageIndex + 1) % totalImages;
  let transitionProgress = 0;
  let transitioning = false;
  const images = [];

  // Function to preload an image asynchronously
  function preloadImage(path, callback) {
    const img = new Image();
    img.src = path;
    img.onload = () => {
      callback(img);
    };
  }

  // Preload only the first image to start the animation
  preloadImage(imagePaths[currentImageIndex], (img) => {
    images[currentImageIndex] = img;
    startAnimation(); // Start animation after the first image is loaded
  });

  const staticCanvas = document.createElement('canvas');
  const staticCtx = staticCanvas.getContext('2d');
  let imageData, buffer32;

  function createStaticOverlay() {
    staticCanvas.width = canvas.width * 2;
    staticCanvas.height = canvas.height * 2;

    imageData = staticCtx.createImageData(staticCanvas.width, staticCanvas.height);
    buffer32 = new Uint32Array(imageData.data.buffer);

    const baseRed = 255;
    const baseGreen = 105;
    const baseBlue = 180;
    const baseColor = (255 << 24) | (baseBlue << 16) | (baseGreen << 8) | baseRed;

    buffer32.fill(baseColor);

    staticCtx.putImageData(imageData, 0, 0);
  }

  function updateStaticOverlay() {
    const totalPixels = buffer32.length;
    const pixelsToUpdate = Math.floor(totalPixels * 0.2); // 20% of total pixels

    for (let i = 0; i < pixelsToUpdate; i++) {
      const index = Math.floor(Math.random() * totalPixels);

      const baseRed = 255;
      const baseGreen = 105;
      const baseBlue = 180;

      const variationRange = 100;
      const red = Math.min(255, Math.max(0, baseRed + (Math.random() - 0.5) * variationRange));
      const green = Math.min(255, Math.max(0, baseGreen + (Math.random() - 0.5) * variationRange));
      const blue = Math.min(255, Math.max(0, baseBlue + (Math.random() - 0.5) * variationRange));

      buffer32[index] = (255 << 24) | (blue << 16) | (green << 8) | red;
    }

    staticCtx.putImageData(imageData, 0, 0);
  }

  function drawScene() {
    const imgHeight = canvas.height;
    const currentImage = images[currentImageIndex];
    const nextImage = images[nextImageIndex];

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Check if the current and next images are loaded before drawing
    if (currentImage && currentImage.complete) {
      const imgWidthCurrent = currentImage.width * (imgHeight / currentImage.height);

      if (transitioning && nextImage && nextImage.complete) {
        const imgWidthNext = nextImage.width * (imgHeight / nextImage.height);

        // Draw current image fading out
        ctx.globalAlpha = 1 - transitionProgress;
        ctx.drawImage(
          currentImage,
          0,
          0,
          currentImage.width,
          currentImage.height,
          (canvas.width - imgWidthCurrent) / 2,
          0,
          imgWidthCurrent,
          imgHeight
        );

        // Draw next image fading in
        ctx.globalAlpha = transitionProgress;
        ctx.drawImage(
          nextImage,
          0,
          0,
          nextImage.width,
          nextImage.height,
          (canvas.width - imgWidthNext) / 2,
          0,
          imgWidthNext,
          imgHeight
        );

        ctx.globalAlpha = 1; // Reset alpha

        const staticOpacity = 1 - transitionProgress;
        ctx.globalAlpha = staticOpacity;

        const prevCompositeOperation = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'color-burn';

        updateStaticOverlay();

        ctx.drawImage(
          staticCanvas,
          0,
          0,
          staticCanvas.width,
          staticCanvas.height,
          0,
          0,
          canvas.width,
          canvas.height
        );

        ctx.globalCompositeOperation = prevCompositeOperation;
        ctx.globalAlpha = 1;
      } else {
        // Draw the current image at full opacity
        ctx.globalAlpha = 1;
        ctx.drawImage(
          currentImage,
          0,
          0,
          currentImage.width,
          currentImage.height,
          (canvas.width - imgWidthCurrent) / 2,
          0,
          imgWidthCurrent,
          imgHeight
        );
      }
    }
  }

  function animate() {
    if (transitioning) {
      transitionProgress += 0.01;

      if (transitionProgress >= 1) {
        transitionProgress = 1;
        transitioning = false;
        currentImageIndex = nextImageIndex;
      }
    }

    drawScene();
    requestAnimationFrame(animate);
  }

  function changeImage() {
    if (!transitioning) {
      transitioning = true;
      transitionProgress = 0;

      nextImageIndex = (currentImageIndex + 1) % totalImages;

      // Preload the next image asynchronously
      preloadImage(imagePaths[nextImageIndex], (img) => {
        images[nextImageIndex] = img;
        createStaticOverlay();
      });
    }
  }

  function startAnimation() {
    animate();
    setInterval(changeImage, 20000);
  }
</script>

</body>
</html>

